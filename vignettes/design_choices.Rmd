---
title: "Design choices"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{design_choices}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(cellpypes)
```

Here I explain why cellpypes is written the way it is written,
so that I can re-evaluate pros and cons systematically before 
changing the code.




# Cellpypes object structure

Cellpype objects have these slots:

  * **raw**: raw UMI counts, N cells in rows, P genes in columns.
  * **neighbors**: either NxN boolean matrix, or Nxk numeric matrix with indices
  * **embed**
  * **classes**: df with columns: class, parent.
    Most recent class is *last* row in data.frame.
  * **rules**: df with columns: class, feature, operator, threshold
    Most recent rule is *last* row in data.frame.
  * **.data**
    * original_object
    * computations: s, S, K of the most recent genes


**classes** and **rules** are separate data.frames because they have 
different unique ('primary') keys. In classes, the class-column uniquely 
identifies an entry, while in rules, it is the combination of the two columns
class and feature.

*class example*
 class  parent
  T     NULL
  Th     T

*rules example*
 class  feature  operator  threshold
  T     CD3E       ">"        .5
  T     MS4A1      "<"        .9
  Th    CD4        ">"        .1


## Rule function

  * Default value *parent = NULL* (and not "..root..").
    This enables the user to ignore the 'parent' argument when additional rules
    are added to an existing class. Cellpypes handles NULL as "use existing parent
    (for new class: use ..root..)".

```{r}
if (is.null(parent)) {
  parent <- ifelse(existing_class,
                   obj$classes$parent[obj$classes==class],
                   "..root..")
}

class_dat <- data.frame(class="T", parent="..root..")
rule_dat  <- data.frame(class="T", feature="CD3E", operator=">", threshold=.1)


# init:
classes <- data.frame(class=c(), parent=c())
# if class is new (!existing_class):
classes <- rbind(class_dat, classes)
# if existing_class:
classes[classes$class=="T"] <- class_dat


# init:
rules <- data.frame(class=c(), feature=c(), operator=c(), threshold=c())
# if class is new (!existing_class):
rules <- rbind(rule_dat, rules) # newest rule is on top
# if existing_class:
rules[rules$class=="T"&&rules$feature=="CD3E"] <- 
```





# Developer's cheat sheet

Good places to read about package development:

  * "Whole game" section in *R packages* (2nd edition):
  https://r-pkgs.org/whole-game.html
  * Writing R extensions:
  https://cran.r-project.org/doc/manuals/R-exts.html#Creating-R-packages
  * how to write functions: https://r4ds.had.co.nz/functions.html#checking-values


Whenever you write a new function:

  1. use_r("foo"); write some function code; use_package("dependency")
  2. RStudio > Code > Insert roxygen2 skeleton
  3. use_test("foo")
    expect_identical, etc. inside test_that
  4. `load_all()`, `document()`, `test()` [or Cntrl+Shift+T], 
    occasionally: `devtools::build_readme()`

Furthermore:
If you are using functions repeatedly, you can avoid :: by importing the function with @importFrom pkg fun.
Operators can also be imported in a similar manner, e.g.,
@importFrom magrittr %>%.


Whenever you're working on the package:
```{R message=FALSE, warning=FALSE}
library(devtools)   # load_all() requires devtools
library(testthat)   # developing unit tests requires testthat::test_that
```



Conditional statements are short one-liners or nicely formatted multiliners:
```{R}
x <- if (10 < 20) "Too low" else "Too high"

if (TRUE || FALSE) {      # never use | or & in if statement because vectorized
  # do that
} else if (TRUE) {
  # do something else
} else {
  # 
}

```

Use spaces:
```{R}
average <- mean(obj_min$embed[,1]/ 12 + obj_min$embed[,2], na.rm = TRUE)   # Good
average<-mean(obj_min$embed[,1]/12+obj_min$embed[,2],na.rm=TRUE)            # Bad
```






# gitHub issues
I use gitHub issues myself a lot to stay organized while developing cellpypes.


**Side-effect functions should return invisible(obj)**
Functions are typically transforming (rule) or side-effects (plot_rule).
Make sure that side-effect functions return the invisible object, so that you
can use them in pipes:
obj %>% rule("T", "CD3E", ">", .1) %>% plot_rule() %>% rule("T", "CD3G", ">", .5)

**Recent genes: save pooled counts**
I do not want to re-compute the pooled counts every time I change the 
threshold value and plot.
Problem: the marker gene which I want to pool is specified together with
  the threshold value, not sure in which use case the counts are already 
  pooled when a new threshold value is specified.
  The problem is that no one will be doing this ever:
  obj %>% rule("T", "CD3E", ">", .1) %>% rule("T", "CD3E", ">", .5)
  
**Check how much of my code is tested**
covr package to check percentage of tested code in package